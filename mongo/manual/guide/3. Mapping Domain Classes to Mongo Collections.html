<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>3 Mapping Domain Classes to Mongo Collections 1.3.0.GA</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8"/>
    <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8"/>
    <script type="text/javascript">
function addJsClass() {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
</head>

<body class="body" onload="addJsClass();">
<div id="navigation">
    <ul>
        <li>
            <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                <a href="../guide/index.html" class="button">Table of contents</a>

                <div id="nav-summary-childs" style="display:none;">
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/1.%20Introduction.html"><strong>1</strong><span>Introduction</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/2.%20Getting%20Started.html"><strong>2</strong><span>Getting Started</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/3.%20Mapping%20Domain%20Classes%20to%20Mongo%20Collections.html"><strong>3</strong><span>Mapping Domain Classes to Mongo Collections</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/4.%20Low-level%20API.html"><strong>4</strong><span>Low-level API</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/5.%20Transactions.html"><strong>5</strong><span>Transactions</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/6.%20Unit%20Testing.html"><strong>6</strong><span>Unit Testing</span></a>
                    </div>
                    
                </div>
            </div>
        </li>
        <li class="separator selected">
            <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
        </li>
    </ul>
</div>
<div id="header">
    <div class="images clearfix">
        
        
    </div>
    <p></p>
</div>


<table id="colset" border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td id="col1">
            <div id="main" class="corner-all">

                
                    <div class="toc-item prev-left"><a href="../guide/2.%20Getting%20Started.html">&lt;&lt; <strong>2</strong><span>Getting Started</span></a></div>
                

                <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                
                    <div class="toc-item next-right"><a href="../guide/4.%20Low-level%20API.html"><strong>4</strong><span>Low-level API</span> >></a></div>
                


                <div class="project">
                    <h1>3 Mapping Domain Classes to Mongo Collections - Reference Documentation</h1>

                    <p><strong>Authors:</strong> Graeme Rocher, Burt Beckwith</p>

                    <p><strong>Version:</strong> 1.3.0.GA</p>

                    
                </div>

                
                <div id="table-of-content">
                    <h2>Table of Contents</h2>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#3.1%20Identity%20Generation"><strong>3.1</strong><span>Identity Generation</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#3.2%20Indexing%20Queries"><strong>3.2</strong><span>Indexing Queries</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#3.3%20Customizing%20the%20WriteConcern"><strong>3.3</strong><span>Customizing the WriteConcern</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#3.4%20Dynamic%20Attributes"><strong>3.4</strong><span>Dynamic Attributes</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#3.5%20Dynamic%20Database%20or%20Collection%20Switching"><strong>3.5</strong><span>Dynamic Database or Collection Switching</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#3.6%20Geospacial%20Querying"><strong>3.6</strong><span>Geospacial Querying</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#3.7%20Custom%20User%20Types"><strong>3.7</strong><span>Custom User Types</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#3.8%20Stateful%20vs.%20Stateless%20Domain%20Classes"><strong>3.8</strong><span>Stateful vs. Stateless Domain Classes</span></a>
                    </div>
                    
                </div>
                

                

<h1 id="3. Mapping Domain Classes to Mongo Collections">3 Mapping Domain Classes to Mongo Collections</h1>
<h4>Basic Mapping</h4><p class="paragraph"/>The way GORM for Mongo works is to map each domain class to a Mongo collection. For example given a domain class such as:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    <span class="java&#45;object">String</span> firstName
    <span class="java&#45;object">String</span> lastName
    <span class="java&#45;keyword">static</span> hasMany = &#91;pets:Pet&#93;
&#125;</pre></div><p class="paragraph"/>This will map onto a Mongo <a href="https://api.mongodb.org/java/current/com/mongodb/DBCollection.html" target="blank">DBCollection</a> called "person".<p class="paragraph"/><h4>Embedded Documents</h4><p class="paragraph"/>It is quite common in Mongo to embed documents within documents (nested documents). This can be done with GORM embedded types:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    <span class="java&#45;object">String</span> firstName
    <span class="java&#45;object">String</span> lastName
    Address address
    <span class="java&#45;keyword">static</span> embedded = &#91;'address'&#93;
&#125;</pre></div><p class="paragraph"/>You can map embedded lists and sets of documents/domain classes:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    <span class="java&#45;object">String</span> firstName
    <span class="java&#45;object">String</span> lastName
    Address address
    List otherAddresses
    <span class="java&#45;keyword">static</span> embedded = &#91;'address', 'otherAddresses'&#93;
&#125;</pre></div><p class="paragraph"/><h4>Basic Collection Types</h4><p class="paragraph"/>You can also map lists and maps of basic types (such as strings) simply by defining the appropriate collection type:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    List&#60;<span class="java&#45;object">String</span>&#62; friends
    Map pets
&#125;<p class="paragraph"/>...<p class="paragraph"/><span class="java&#45;keyword">new</span> Person(friends:&#91;'Fred', 'Bob'&#93;, pets:&#91;chuck:<span class="java&#45;quote">"Dog"</span>, eddie:'Parrot'&#93;).save(flush:<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>Basic collection types are stored as native ArrayList and BSON documents within the Mongo documents.<p class="paragraph"/><h4>Customized Collection and Database Mapping</h4><p class="paragraph"/>You may wish to customize how a domain class maps onto a <code>DBCollection</code>. This is possible using the <code>mapping</code> block as follows:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    ..
    <span class="java&#45;keyword">static</span> mapping = &#123;
        collection <span class="java&#45;quote">"mycollection"</span>
        database <span class="java&#45;quote">"mydb"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>In this example we see that the <code>Person</code> entity has been mapped to a collection called "mycollection" in a database called "mydb".<p class="paragraph"/>You can also control how an individual property maps onto a Mongo Document field (the default is to use the property name itself):<p class="paragraph"/><div class="code"><pre>class Person &#123;
    ..
    <span class="java&#45;keyword">static</span> mapping = &#123;
        firstName attr:<span class="java&#45;quote">"first_name"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>For non-embedded associations by default GORM for MongoDB will map links between documents using MongoDB <a href="https://www.mongodb.org/display/DOCS/Database+References" target="blank">database references</a> also known as <code>DBRefs</code>.<p class="paragraph"/>If you prefer not to use DBRefs then you tell GORM to use direct links by using the <code>reference:false</code> mapping:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    ..
    <span class="java&#45;keyword">static</span> mapping = &#123;
        address reference:<span class="java&#45;keyword">false</span>
    &#125;
&#125;</pre></div>



<h2 id="3.1 Identity Generation">3.1 Identity Generation</h2>
By default in GORM entities are supplied with an integer-based identifier. So for example the following entity:<p class="paragraph"/><div class="code"><pre>class Person &#123;&#125;</pre></div><p class="paragraph"/>Has a property called <code>id</code> of type <code>java.lang.Long</code>. In this case GORM for Mongo will generate a sequence based identifier using the technique <a href="https://www.mongodb.org/display/DOCS/Atomic+Operations" target="blank">described in the Mongo documentation</a> on Atomic operations.<p class="paragraph"/>However, sequence based integer identifiers are not ideal for environments that require <a href="https://www.mongodb.org/display/DOCS/Sharding" target="blank">sharding</a> (one of the nicer features of Mongo). Hence it is generally advised to use either String based ids:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    <span class="java&#45;object">String</span> id
&#125;</pre></div><p class="paragraph"/>Or a native BSON <a href="https://api.mongodb.org/java/current/org/bson/types/ObjectId.html" target="blank">ObjectId</a>:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> org.bson.types.ObjectId<p class="paragraph"/>class Person &#123;
    ObjectId id
&#125;</pre></div><p class="paragraph"/>BSON <code>ObjectId</code> instances are generated in a similar fashion to <code>UUIDs</code>.


<h2 id="3.2 Indexing Queries">3.2 Indexing Queries</h2>
<h4>Basics</h4><p class="paragraph"/>Mongo doesn't require that you specify indices to query, but like a relational database without specifying indices your queries will be significantly slower.<p class="paragraph"/>With that in mind it is important to specify the properties you plan to query using the mapping block:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> mapping = &#123;
        name index:<span class="java&#45;keyword">true</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>With the above mapping a Mongo index will be automatically created for you. You can customize the index options using the <code>indexAttributes</code> configuration parameter:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> mapping = &#123;
        name index:<span class="java&#45;keyword">true</span>, indexAttributes: &#91;unique:<span class="java&#45;keyword">true</span>, dropDups:<span class="java&#45;keyword">true</span>&#93;
    &#125;
&#125;</pre></div><p class="paragraph"/>You can use MongoDB <a href="https://www.mongodb.org/display/DOCS/Optimization#Optimization-Hint" target="blank">Query Hints</a> by passing the <code>hint</code> argument to any dynamic finder:<p class="paragraph"/><div class="code"><pre>def people = Person.findByName(<span class="java&#45;quote">"Bob"</span>, &#91;hint:&#91;name:1&#93;&#93;)</pre></div><p class="paragraph"/>Or in a criteria query using the query "arguments" method<p class="paragraph"/><div class="code"><pre>Person.withCriteria &#123;
	eq 'firstName', 'Bob'
    arguments hint:&#91;<span class="java&#45;quote">"firstName"</span>:1&#93;
&#125;</pre></div><p class="paragraph"/><h4>Compound Indices</h4><p class="paragraph"/>MongoDB supports the notion of <a href="https://www.mongodb.org/display/DOCS/Indexes#Indexes-CompoundKeys" target="blank">compound keys</a>. GORM for MongoDB enables this feature at the mapping level using the <code>compoundIndex</code> mapping:<p class="paragraph"/><div class="code"><pre>class Person &#123;
    &#8230;
    <span class="java&#45;keyword">static</span> mapping = &#123;
        compoundIndex name:1, age:&#45;1
    &#125;
&#125;</pre></div><p class="paragraph"/>As per the MongoDB docs 1 is for ascending and -1 is for descending.


<h2 id="3.3 Customizing the WriteConcern">3.3 Customizing the WriteConcern</h2>
A feature of Mongo is its ability to customize how important a database write is to the user. The Java client models this as a <a href="https://api.mongodb.org/java/current/com/mongodb/WriteConcern.html" target="blank">WriteConcern</a> and there are various options that indicate whether the client cares about server or network errors, or whether the data has been successfully written or not.<p class="paragraph"/>If you wish to customize the <code>WriteConcern</code> for a domain class you can do so in the mapping block:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> com.mongodb.WriteConcern<p class="paragraph"/>class Person &#123;
    <span class="java&#45;object">String</span> name
    <span class="java&#45;keyword">static</span> mapping = &#123;
        writeConcern WriteConcern.FSYNC_SAFE
    &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
For versioned entities, if a lower level of WriteConcern than WriteConcern.ACKNOWLEDGE is specified, WriteConcern.ACKNOWLEDGE will also be used for updates, to ensure that optimistic locking failures are reported.
</blockquote>


<h2 id="3.4 Dynamic Attributes">3.4 Dynamic Attributes</h2>
Unlike a relational database, Mongo allows for "schemaless" persistence where there are no limits to the number of attributes a particular document can have. A GORM domain class on the other hand has a schema in that there are a fixed number of properties. For example consider the following domain class:<p class="paragraph"/><div class="code"><pre>class Plant &#123;
    <span class="java&#45;object">boolean</span> goesInPatch
    <span class="java&#45;object">String</span> name
&#125;</pre></div><p class="paragraph"/>Here there are two fixed properties, <code>name</code> and <code>goesInPatch</code>, that will be persisted into the Mongo document. Using GORM for Mongo you can however use dynamic properties via the Groovy subscript operator. For example:<p class="paragraph"/><div class="code"><pre>def p = <span class="java&#45;keyword">new</span> Plant(name:<span class="java&#45;quote">"Pineapple"</span>)
p&#91;'color'&#93; = 'Yellow'
p&#91;'hasLeaves'&#93; = <span class="java&#45;keyword">true</span>
p.save()<p class="paragraph"/>p = Plant.findByName(<span class="java&#45;quote">"Pineapple"</span>)<p class="paragraph"/>println p&#91;'color'&#93;
println p&#91;'hasLeaves'&#93;</pre></div><p class="paragraph"/>Using the subscript operator you can add additional attributes to the underlying <code>DBObject</code> instance that gets persisted to the Mongo allowing for more dynamic domain models. 


<h2 id="3.5 Dynamic Database or Collection Switching">3.5 Dynamic Database or Collection Switching</h2>
In addition to storing dynamic attributes, as of version 1.3.0 of the plugin you can also switch which database and/or collection to persist to at runtime.<p class="paragraph"/>For example:<p class="paragraph"/><div class="code"><pre>Person.withDatabase(<span class="java&#45;quote">"administrators"</span>) &#123;
    <span class="java&#45;keyword">new</span> Person(name:<span class="java&#45;quote">"Bob"</span>).save()
&#125;</pre></div><p class="paragraph"/>The above example will save a <code>Person</code> instance to the 'administrators' database. The database is used for the scope of the closure. You can switch database for the scope of the active session:<p class="paragraph"/><div class="code"><pre>Person.useDatabase(<span class="java&#45;quote">"administrators"</span>) 
<span class="java&#45;keyword">new</span> Person(name:<span class="java&#45;quote">"Bob"</span>).save()</pre></div><p class="paragraph"/>In addition, there are equivalent <code>withCollection</code> and <code>useCollection</code> methods for switching collection at runtime.



<h2 id="3.6 Geospacial Querying">3.6 Geospacial Querying</h2>
It is possible to use Mongo's <a href="https://www.mongodb.org/display/DOCS/Geospatial+Indexing" target="blank">Geospacial querying</a> capability by mapping a list or map property using the <code>geoIndex</code> mapping:<p class="paragraph"/><div class="code"><pre>class Hotel &#123;
    <span class="java&#45;object">String</span> name
    List location<p class="paragraph"/>    <span class="java&#45;keyword">static</span> mapping = &#123;
        location geoIndex:<span class="java&#45;keyword">true</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>By default the index creation assumes latitude/longitude and thus is configured for a -180..180 range. If you are indexing something else you can customise this with <code>indexAttributes</code><p class="paragraph"/><div class="code"><pre>class Hotel &#123;
    <span class="java&#45;object">String</span> name
    List location<p class="paragraph"/>    <span class="java&#45;keyword">static</span> mapping = &#123;
        location geoIndex:<span class="java&#45;keyword">true</span>, indexAttributes:&#91;min:&#45;500, max:500&#93;
    &#125;
&#125;</pre></div><p class="paragraph"/>You can then save Geo locations using a two dimensional list:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Hotel(name:<span class="java&#45;quote">"Hilton"</span>, location:&#91;50, 50&#93;).save()</pre></div><p class="paragraph"/>Alternatively you can use a map with keys representing latitude and longitude:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">new</span> Hotel(name:<span class="java&#45;quote">"Hilton"</span>, location:&#91;lat: 40.739037d, <span class="java&#45;object">long</span>: 73.992964d&#93;).save()</pre></div><p class="paragraph"/><blockquote class="note">
You must specify whether the number of a floating point or double by adding a 'd' or 'f' at the end of the number eg. 40.739037d. Groovy's default type for decimal numbers is <code>BigDecimal</code> which is not supported by MongoDB.
</blockquote><p class="paragraph"/>Once you have your data indexed you can use Mongo specific dynamic finders to find hotels near a given a location:<p class="paragraph"/><div class="code"><pre>def h = Hotel.findByLocationNear(&#91;50, 60&#93;)
assert h.name == 'Hilton'</pre></div><p class="paragraph"/>You can also find a location within a box (bound queries). Boxes are defined by specifying the lower-left and upper-right corners:<p class="paragraph"/><div class="code"><pre>def box = &#91;&#91;40.73083d, &#45;73.99756d&#93;, &#91;40.741404d,  &#45;73.988135d&#93;&#93;
def h = Hotel.findByLocationWithinBox(box)</pre></div><p class="paragraph"/>You can also find a location within a circle. Circles are specified using a center and radius:<p class="paragraph"/><div class="code"><pre>def center = &#91;50, 50&#93;
def radius = 10
def h = Hotel.findByLocationWithinCircle(&#91;center, radius&#93;)</pre></div><p class="paragraph"/>If you plan on querying a location and some other value it is recommended to use a compound index:<p class="paragraph"/><div class="code"><pre>class Hotel &#123;
    <span class="java&#45;object">String</span> name
    List location
    <span class="java&#45;object">int</span> stars<p class="paragraph"/>    <span class="java&#45;keyword">static</span> mapping = &#123;
        compoundIndex location:<span class="java&#45;quote">"2d"</span>, stars:1
    &#125;
&#125;</pre></div><p class="paragraph"/>In the example above you an index is created for both the location and the number of stars a <code>Hotel</code> has.



<h2 id="3.7 Custom User Types">3.7 Custom User Types</h2>
GORM for MongoDB will persist all common known Java types like String, Integer, URL etc., however if you want to persist one of your own classes that is not a domain class you can implement a custom user type. For example consider the following class:<p class="paragraph"/><div class="code"><pre>class Birthday <span class="java&#45;keyword">implements</span> Comparable&#123;
    Date date<p class="paragraph"/>    Birthday(Date date) &#123;
        <span class="java&#45;keyword">this</span>.date = date
    &#125;<p class="paragraph"/>    @Override
    <span class="java&#45;object">int</span> compareTo(<span class="java&#45;object">Object</span> t) &#123;
        date.compareTo(t.date)
    &#125;
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Custom types should go in src/groovy not grails-app/domain
</blockquote><p class="paragraph"/>If you attempt to reference this class from a domain class it will not automatically be persisted for you. However you can create a custom type implementation and register it with Spring. For example:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> com.mongodb.BasicDBObject;
<span class="java&#45;keyword">import</span> com.mongodb.DBObject;
<span class="java&#45;keyword">import</span> org.grails.datastore.mapping.engine.types.AbstractMappingAwareCustomTypeMarshaller;
<span class="java&#45;keyword">import</span> org.grails.datastore.mapping.model.PersistentProperty;
<span class="java&#45;keyword">import</span> org.grails.datastore.mapping.mongo.query.MongoQuery;
<span class="java&#45;keyword">import</span> org.grails.datastore.mapping.query.Query;<p class="paragraph"/>class BirthdayType <span class="java&#45;keyword">extends</span> AbstractMappingAwareCustomTypeMarshaller&#60;Birthday, DBObject, DBObject&#62; &#123;
	BirthdayType() &#123;
		<span class="java&#45;keyword">super</span>(Birthday)
	&#125;
    @Override
    <span class="java&#45;keyword">protected</span> <span class="java&#45;object">Object</span> writeInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, Birthday value, DBObject nativeTarget) &#123;
        <span class="java&#45;keyword">final</span> converted = value.date.time
        nativeTarget.put(key, converted)
        <span class="java&#45;keyword">return</span> converted
    &#125;<p class="paragraph"/>    @Override
    <span class="java&#45;keyword">protected</span> void queryInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, Query.PropertyCriterion criterion, DBObject nativeQuery) &#123;
        <span class="java&#45;keyword">if</span>(criterion <span class="java&#45;keyword">instanceof</span> Between) &#123;
            def dbo = <span class="java&#45;keyword">new</span> BasicDBObject()
            dbo.put(MongoQuery.MONGO_GTE_OPERATOR, criterion.getFrom().date.time);
            dbo.put(MongoQuery.MONGO_LTE_OPERATOR, criterion.getTo().date.time);
            nativeQuery.put(key, dbo)
        &#125;
        <span class="java&#45;keyword">else</span> &#123;
            nativeQuery.put(key, criterion.value.date.time)
        &#125;<p class="paragraph"/>    &#125;<p class="paragraph"/>    @Override
    <span class="java&#45;keyword">protected</span> Birthday readInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, DBObject nativeSource) &#123;
        <span class="java&#45;keyword">final</span> num = nativeSource.get(key)
        <span class="java&#45;keyword">if</span>(num <span class="java&#45;keyword">instanceof</span> <span class="java&#45;object">Long</span>) &#123;
            <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> Birthday(<span class="java&#45;keyword">new</span> Date(num))
        &#125;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>The above <code>BirthdayType</code> class is a custom user type implementation for MongoDB for the <code>Birthday</code> class. It provides implementations for three methods: <code>readInternal</code>, <code>writeInternal</code> and the optional <code>queryInternal</code>. If you do not implement <code>queryInternal</code> your custom type can be persisted but not queried.<p class="paragraph"/>The <code>writeInternal</code> method gets passed the property, the key to store it under, the value and the native DBObject where the custom type is to be stored:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> <span class="java&#45;object">Object</span> writeInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, Birthday value, DBObject nativeTarget) &#123;
    <span class="java&#45;keyword">final</span> converted = value.date.time
    nativeTarget.put(key, converted)
    <span class="java&#45;keyword">return</span> converted
&#125;</pre></div><p class="paragraph"/>You can then read the values of the custom type and register them with the <code>DBObject</code>. The <code>readInternal</code> method gets passed the <code>PersistentProperty</code>, the key the user type info is stored under (although you may want to use multiple keys) and the <code>DBObject</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> Birthday readInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, DBObject nativeSource) &#123;
    <span class="java&#45;keyword">final</span> num = nativeSource.get(key)
    <span class="java&#45;keyword">if</span>(num <span class="java&#45;keyword">instanceof</span> <span class="java&#45;object">Long</span>) &#123;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> Birthday(<span class="java&#45;keyword">new</span> Date(num))
    &#125;
    <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>
&#125;</pre></div><p class="paragraph"/>You can then construct the custom type by reading values from the <code>DBObject</code>. Finally the <code>queryInternal</code> method allows you to handle how a custom type is queried:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> void queryInternal(PersistentProperty property, <span class="java&#45;object">String</span> key, Query.PropertyCriterion criterion, DBObject nativeQuery) &#123;
    <span class="java&#45;keyword">if</span>(criterion <span class="java&#45;keyword">instanceof</span> Between) &#123;
        def dbo = <span class="java&#45;keyword">new</span> BasicDBObject()
        dbo.put(MongoQuery.MONGO_GTE_OPERATOR, criterion.getFrom().date.time);
        dbo.put(MongoQuery.MONGO_LTE_OPERATOR, criterion.getTo().date.time);
        nativeQuery.put(key, dbo)
    &#125;
    <span class="java&#45;keyword">else</span> <span class="java&#45;keyword">if</span>(criterion <span class="java&#45;keyword">instanceof</span> Equals)&#123;
        nativeQuery.put(key, criterion.value.date.time)
    &#125;
    <span class="java&#45;keyword">else</span> &#123;
	    <span class="java&#45;keyword">throw</span> <span class="java&#45;keyword">new</span> RuntimeException(<span class="java&#45;quote">"unsupported query type <span class="java&#45;keyword">for</span> property $property"</span>)
    &#125;
&#125;</pre></div><p class="paragraph"/>The method gets passed a <code>criterion</code> which is the type of query and depending on the type of query you may handle the query differently. For example the above implementation supports <code>between</code> and <code>equals</code> style queries. So the following 2 queries will work:<p class="paragraph"/><div class="code"><pre>Person.findByBirthday(<span class="java&#45;keyword">new</span> Birthday(<span class="java&#45;keyword">new</span> Date()&#45;7)) // find someone who was born 7 days ago
Person.findByBirthdayBetween(<span class="java&#45;keyword">new</span> Birthday(<span class="java&#45;keyword">new</span> Date()&#45;7), <span class="java&#45;keyword">new</span> Birthday(<span class="java&#45;keyword">new</span> Date())) // find someone who was born in the last 7 days</pre></div><p class="paragraph"/>However "like" or other query types will not work.<p class="paragraph"/>To register a custom type in a grails application simply register it as Spring bean. For example, to register the above <code>BirthdayType</code> add the following to grails-app/conf/spring/resources.groovy:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> com.example.BirthdayType<p class="paragraph"/>// Place your Spring DSL code here
beans = &#123;
  birthdayType(BirthdayType)
&#125;</pre></div>



<h2 id="3.8 Stateful vs. Stateless Domain Classes">3.8 Stateful vs. Stateless Domain Classes</h2>
GORM for MongoDB supports both stateless and stateful modes for mapping domain classes to MongoDB. In general stateful mapping is superior for write heavy applications and stateless mode better for read heavy applications (particularily when large amounts of data is involved).<p class="paragraph"/><h4>Stateful mode</h4><p class="paragraph"/>Domain classes are by default stateful, which means when they are read from a MongoDB document their state is stored in the user session (which is typically bound to the request in Grails). This has several advantages for write heavy applications:
<ul class="star">
<li>GORM can automatically detect whether a call to save() is a an update or an insert and act appropriately</li>
<li>GORM store the state of the read MongoDB document and therefore updates to schemaless properties don't require an extra query</li>
<li>GORM can store the version and therefore implement optimistic locking</li>
<li>Repeated reads of the same entity can be retrieved from the cache, thus optimizing reads as well</li>
</ul><p class="paragraph"/>For an example of when a stateful domain class is better consider the following:<p class="paragraph"/><div class="code"><pre>def b = Book.get(1)
b&#91;'pages'&#93; = 400
b&#91;'publisher'&#93; = 'Manning'
b&#91;'rating'&#93; = 5
b.save(flush:<span class="java&#45;keyword">true</span>)</pre></div><p class="paragraph"/>With a stateful entity the updates to the three properties can be batched up and executed in the save() call, when there is no state then 3 updates needs to be executed for each schemaless property (ouch!).<p class="paragraph"/>
<h4>Stateless Domain classes</h4><p class="paragraph"/>However, stateful domain classes can cause problems for read-heavy applications. Take for example the following code:<p class="paragraph"/><div class="code"><pre>def books = Book.list() // read 100,000 books
<span class="java&#45;keyword">for</span>(b in books) &#123;
    println b.title
&#125;</pre></div><p class="paragraph"/>The above example will read 100,000 books and print the title of each. In stateful mode this will almost certainly run out of memory as each MongoDB document is stored in user memory as is each book. Rewriting the code as follows will solve the problem:<p class="paragraph"/><div class="code"><pre>Book.withStatelessSession &#123;
    def books = Book.list() // read 100,000 books
    <span class="java&#45;keyword">for</span>(b in books) &#123;
        println b.title
    &#125;    
&#125;</pre></div><p class="paragraph"/>Alternatively you can map the domain class as stateless, in which case its state will never be stored in the session:<p class="paragraph"/><div class="code"><pre>class Book &#123;
    &#8230;
    <span class="java&#45;keyword">static</span> mapping = &#123;
        stateless <span class="java&#45;keyword">true</span>
    &#125;
&#125;</pre></div><p class="paragraph"/><h4>Disadvantages of Stateless Mode</h4><p class="paragraph"/>There are several disadvantages to using stateless domain classes as the default. One disadvantage is that if you are using assigned identifiers GORM cannot detect whether you want to do an insert or an update so you have to be explicit about which one you want:<p class="paragraph"/><div class="code"><pre>def b = <span class="java&#45;keyword">new</span> Book(id:<span class="java&#45;quote">"The Book"</span>)
b.insert()</pre></div><p class="paragraph"/>In the above case we use the explicit 'insert' method to tell Grails this is an insert not an udpate. Another disadvantage is that reading of schemaless/dynamic properties is more costly. For example:<p class="paragraph"/>
<div class="code"><pre>def books = Book.list() // read 100,000 books
<span class="java&#45;keyword">for</span>(b in books) &#123;
    println b&#91;'pages'&#93;
    println b&#91;'rating'&#93;
&#125;</pre></div><p class="paragraph"/>Here GORM has to execute an additional read method for each schemaless property! This is better written as:<p class="paragraph"/><div class="code"><pre>def books = Book.list() // read 100,000 books
<span class="java&#45;keyword">for</span>(b in books) &#123;
    def dbo = b.dbo
    println dbo&#91;'pages'&#93;
    println dbo&#91;'rating'&#93;
&#125;</pre></div><p class="paragraph"/>Thus only requiring one query. Or alternatively you can use the native API:<p class="paragraph"/><div class="code"><pre>def books = Book.collection.find() // read 100,000 books
<span class="java&#45;keyword">for</span>(dbo in books) &#123;
    Book b = dbo as Book    
    println dbo&#91;'pages'&#93;
    println dbo&#91;'rating'&#93;
&#125;</pre></div><p class="paragraph"/>Which would be more efficient.<p class="paragraph"/>



                <div style="clear:both;margin-top:15px;"></div>
                
                    <div class="toc-item prev-left"><a href="../guide/2.%20Getting%20Started.html">&lt;&lt; <strong>2</strong><span>Getting Started</span></a></div>
                
                    <div class="toc-item next-right"><a href="../guide/4.%20Low-level%20API.html"><strong>4</strong><span>Low-level API</span> >></a></div>
                
                <div style="clear:both"></div>
            </div>
        </td>
        <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Beans</h1><div class="menu-sub">
                        
                            
                            <div class="menu-item"><a href="../ref/Beans/mongo.html">mongo</a>
                            </div>
                            
                            </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Domain Classes</h1><div class="menu-sub">
                        
                            
                            <div class="menu-item"><a href="../ref/Domain%20Classes/DB.html">DB</a>
                            </div>
                            
                            <div class="menu-item"><a href="../ref/Domain%20Classes/collection.html">collection</a>
                            </div>
                            
                            <div class="menu-item"><a href="../ref/Domain%20Classes/collectionName.html">collectionName</a>
                            </div>
                            
                            <div class="menu-item"><a href="../ref/Domain%20Classes/dbo.html">dbo</a>
                            </div>
                            
                            <div class="menu-item"><a href="../ref/Domain%20Classes/useCollection.html">useCollection</a>
                            </div>
                            
                            <div class="menu-item"><a href="../ref/Domain%20Classes/useDatabase.html">useDatabase</a>
                            </div>
                            
                            <div class="menu-item"><a href="../ref/Domain%20Classes/withCollection.html">withCollection</a>
                            </div>
                            
                            <div class="menu-item"><a href="../ref/Domain%20Classes/withDatabase.html">withDatabase</a>
                            </div>
                            
                            </div>
                    </div>
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Testing</h1><div class="menu-sub">
                        
                            
                            <div class="menu-item"><a href="../ref/Testing/DatastoreUnitTestMixin.html">DatastoreUnitTestMixin</a>
                            </div>
                            
                            </div>
                    </div>
                    
                </div>
            </div>
        </td>
    </tr>
</table>

<div id="footer">
    
    
</div>

<script type="text/javascript" src="../js/docs.js"></script>

</body>
</html>
