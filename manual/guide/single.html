<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
    <head>
        <title>GORM Datastore API 1.0.0</title>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8" />
        <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8" />
    <script type="text/javascript">
function addJsClass(el) {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
    </head>

    <body class="body" onload="addJsClass();">
        <div id="navigation">
            <ul>
                <li>
                    <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                        <a href="../guide/index.html" class="button">Table of contents</a>
                        <div id="nav-summary-childs" style="display:none;">
                            
                            <div class="toc-item" style="margin-left:0"><a href="#1.%20Introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#2.%20Getting%20Started"><strong>2</strong><span>Getting Started</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#3.%20Understanding%20the%20Low-level%20API"><strong>3</strong><span>Understanding the Low-level API</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#4.%20GORM%20Enhancer"><strong>4</strong><span>GORM Enhancer</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#5.%20Using%20the%20Test%20Compatibility%20Kit"><strong>5</strong><span>Using the Test Compatibility Kit</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0"><a href="#6.%20Creating%20a%20GORM%20implementatio%20Step%20by%20Step"><strong>6</strong><span>Creating a GORM implementatio Step by Step</span></a></div>
                            
                        </div>
                    </div>
                </li>
                <li class="separator selected">
                    <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
                </li>
            </ul>
        </div>
        <div id="header">
            <div class="images clearfix">
                
                
            </div>
            <p></p>
        </div>


        <table id="colset" border="0" cellpadding="0" cellspacing="0">
            <tr>
                <td id="col1">
                    <div id="main" class="corner-all">

                        <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                        <div class="project">
                            <h1>GORM Datastore API - Reference Documentation</h1>
                            <p><strong>Authors:</strong> Graeme Rocher</p>
                            <p><strong>Version:</strong> 1.0.0</p>
                            
                        </div>

                        
                        <div id="table-of-content">
                            <h2>Table of Contents</h2>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#1.%20Introduction"><strong>1</strong><span>Introduction</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#2.%20Getting%20Started"><strong>2</strong><span>Getting Started</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#3.%20Understanding%20the%20Low-level%20API"><strong>3</strong><span>Understanding the Low-level API</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#3.1%20Datastore%20Basics"><strong>3.1</strong><span>Datastore Basics</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#3.2%20Implementing%20CRUD"><strong>3.2</strong><span>Implementing CRUD</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#3.3%20Secondary%20Indices"><strong>3.3</strong><span>Secondary Indices</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#3.4%20Implementing%20Querying"><strong>3.4</strong><span>Implementing Querying</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#4.%20GORM%20Enhancer"><strong>4</strong><span>GORM Enhancer</span></a></div>
                            
                            <div class="toc-item" style="margin-left:10px"><a href="#4.1%20GORM%20APIs"><strong>4.1</strong><span>GORM APIs</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#5.%20Using%20the%20Test%20Compatibility%20Kit"><strong>5</strong><span>Using the Test Compatibility Kit</span></a></div>
                            
                            <div class="toc-item" style="margin-left:0px"><a href="#6.%20Creating%20a%20GORM%20implementatio%20Step%20by%20Step"><strong>6</strong><span>Creating a GORM implementatio Step by Step</span></a></div>
                            
                            <div style="clear:both" ></div>
                        </div>
                        
                        

<h1 id="1. Introduction">1 Introduction</h1>
This documentation describes the GORM API mechanics and how a datastore implementation can be built to interface to any database providing a GORM API onto it. This documentation is mainly targeted at developers interested in creating implementations of GORM ontop of alternative datastores.<p class="paragraph"/>As of this writing the project has several implementations of GORM against a variety of different datastore implementations. Current implementations include:
<ul class="star">
<li>Hibernate (currently part of the Grails source code)</li>
<li>JPA</li>
<li>MongoDB</li>
<li>Redis</li>
<li>Neo4j</li>
<li>Riak</li>
<li>Amazon SimpleDB</li>
<li>java.util.ConcurrentHashMap (the fastest datastore in the world)</li>
</ul><p class="paragraph"/>The remainder of this document describes how to project is structured, how to build a project and how to implement a GORM provider.<p class="paragraph"/><p class="paragraph"/><p class="paragraph"/>


<h1 id="2. Getting Started">2 Getting Started</h1>
<h3>Checking out and Building </h3><p class="paragraph"/>The project is currently hosted on Github at https://github.com/SpringSource/grails-data-mapping.<p class="paragraph"/>You are free to fork the project from there or clone it anonymously using git:<p class="paragraph"/><div class="code"><pre>git clone git@github.com:SpringSource/grails&#45;data&#45;mapping.git
cd grails&#45;data&#45;mapping</pre></div><p class="paragraph"/>The project has a <a href="https://gradle.org" target="blank">Gradle</a> build. You can generate Eclipse or Intellij project files to open the project using:<p class="paragraph"/><div class="code"><pre>./gradlew eclipse</pre></div><p class="paragraph"/>Or<p class="paragraph"/><div class="code"><pre>./gradlew idea</pre></div><p class="paragraph"/>Once this is done your can import the project into Eclipse, or in the case of Intellij open up the generated <code>grails-data-mapping.ipr</code> file.<p class="paragraph"/><blockquote class="note">
The version of Gradle used has a bug whereby a subproject is generated for the root directory called "grails-data-mapping". You should remove this subproject from your Intellij Modules or delete it it from Eclipse.
</blockquote><p class="paragraph"/>To build the project you can run the <code>assemble</code> task:<p class="paragraph"/><div class="code"><pre>./gradlew assemble</pre></div><p class="paragraph"/>To install the jar files for the various subprojects into your local Maven repository you can run:<p class="paragraph"/><div class="code"><pre>./gradlew install</pre></div><p class="paragraph"/>To build all of the documentation run the command:<p class="paragraph"/><div class="code"><pre>./gradlew allDocs</pre></div><p class="paragraph"/>Documentation will produced in the <code>build/docs</code> directory.<p class="paragraph"/><blockquote class="note">
If you experience PermGen errors when building documentation you may need to increase the JVM permgen inside GRADLE_OPTS
</blockquote><p class="paragraph"/><h3>Project Structure</h3><p class="paragraph"/>The project is essentially a multi-project Gradle build. There is a core API and then subprojects that implement that API. The core API subprojects include:
<ul class="star">
<li><code>grails-datastore-core</code> - The core API, this provides core interfaces for implementing a GORM provider</li>
<li><code>grails-datastore-gorm</code> - The runtime meta-programming and AST transformation infrastructure behind GORM. Also provides end users APIs like <code>grails.gorm.CriteriaBuilder</code> and <code>grails.gorm.DetachedCriteria</code></li>
<li><code>grails-datastore-gorm-plugin-support</code> - Support classes for easing the writing of a GORM plugin for Grails</li>
<li><code>grails-datastore-gorm-tck</code> - The TCK that includes hundreds of Spock specifications that a GORM implementation will need to pass</li>
<li><code>grails-datastore-web</code> - Classes required to integrate GORM into a web tier</li>
</ul><p class="paragraph"/>Beyond these core subprojects there are implementations for various datastores. For example:
<ul class="star">
<li><code>grails-datastore-gemfire/grails-datastore-gorm-gemfire</code> - GORM for Gemfire project <a href="https://grails.org/plugin/gemfire" target="blank"></a></li>
<li><code>grails-datastore-jpa/grails-datastore-gorm-jpa</code> - GORM for JPA project <a href="https://grails.org/plugin/gorm-jpa" target="blank"></a></li>
<li><code>grails-datastore-mongo/grails-datastore-gorm-mongo</code> - GORM for MongoDB project <a href="https://grails.org/plugin/mongodb" target="blank"></a></li>
<li><code>grails-datastore-neo4j</code> - GORM for Neo4j project <a href="https://grails.org/plugin/neo4j" target="blank"></a></li>
<li><code>grails-datastore-redis/grails-datastore-gorm-redis</code> - GORM for Redis project <a href="https://grails.org/plugin/redis" target="blank"></a></li>
<li><code>grails-datastore-riak/grails-datastore-gorm-riak</code> - GORM for Riak project <a href="https://grails.org/plugin/riak" target="blank"></a></li>
<li><code>grails-datastore-simpledb/grails-datastore-gorm-simpledb</code> - GORM for SimpleDB project <a href="https://grails.org/plugin/simpledb" target="blank"></a></li>
</ul><p class="paragraph"/>Some implementations are split into 2 subprojects others are not. It depends whether the author chooses to divide the Java parts and the Groovy parts of the project implementation. It is not a requirement to do so.<p class="paragraph"/>The documentation for each implementation is kept in the documentation subprojects that start with <code>grails-documentation</code>. There are documentation projects for the core API, MongoDB, Neo4j, Redis, Riak and Amazon SimpleDB.<p class="paragraph"/>Finally the Grails plugins that are used to distribute the GORM implementations to end users can be found in the <code>grails-plugins</code> directory.<p class="paragraph"/><p class="paragraph"/>


<h1 id="3. Understanding the Low-level API">3 Understanding the Low-level API</h1>
<h3>Introduction</h3><p class="paragraph"/>The GORM Datastore API is split into a low-level API that implementors need to implement for each individual datastore and then set of higher level APIs that enhance domain classes with things regular users see such as dynamic finders, criteria queries and so on.<p class="paragraph"/>The low-level API classes are found in the <code>grails-datastore-core</code> subproject, whilst the higher level APIs used to enhance domain classes are found in <code>grails-datastore-gorm</code>. In this section we will discuss the low-level API.<p class="paragraph"/>



<h2 id="3.1 Datastore Basics">3.1 Datastore Basics</h2>
<h3>The MappingContext</h3><p class="paragraph"/>The <code>org.grails.datastore.mapping.model.MappingContext</code> interface is used to obtain metadata about the classes that are configured for persistence. There are <code>org.grails.datastore.mapping.model.PersistentEntity</code> and <code>org.grails.datastore.mapping.model.PersistentProperty</code> interfaces that represent a class and its properties respectively. These can be obtained and introspected via the <code>MappingContext</code>.<p class="paragraph"/>There are various concrete implementations of the <code>MappingContext</code> interface such as:
<ul class="star">
<li><code>DocumentMappingContext</code> - Used for document stores, subclassed by <code>MongoMappingContext</code></li>
<li><code>JpaMappingContext</code> - Used for JPA</li>
<li><code>KeyValueMappingContext</code> - Used by key/value stores</li>
</ul><p class="paragraph"/>Creating a new <code>MappingContext</code> may be useful because it allows users to configure how a class is mapped to the underlying datastore using GORM's <code>mapping</code> block as well as allowing registration of custom type converters and so on. The implementation for Neo4j looks like this:<p class="paragraph"/><div class="code"><pre>class Neo4jMappingContext <span class="java&#45;keyword">extends</span> AbstractMappingContext &#123;<p class="paragraph"/>    MappingFactory&#60;Collection, Attribute&#62; mappingFactory
    MappingConfigurationStrategy syntaxStrategy<p class="paragraph"/>    Neo4jMappingContext() &#123;
        mappingFactory = <span class="java&#45;keyword">new</span> GraphGormMappingFactory()
        syntaxStrategy = <span class="java&#45;keyword">new</span> GormMappingConfigurationStrategy(mappingFactory)
        //addTypeConverter(<span class="java&#45;keyword">new</span> StringToNumberConverterFactory().getConverter(BigDecimal))
        addTypeConverter(<span class="java&#45;keyword">new</span> StringToShortConverter())
        addTypeConverter(<span class="java&#45;keyword">new</span> StringToBigIntegerConverter())
         &#8230;
    &#125;<p class="paragraph"/>    @Override
    <span class="java&#45;keyword">protected</span> PersistentEntity createPersistentEntity(<span class="java&#45;object">Class</span> javaClass) &#123;
        GraphPersistentEntity persistentEntity = <span class="java&#45;keyword">new</span> GraphPersistentEntity(javaClass, <span class="java&#45;keyword">this</span>)
        mappingFactory.createMappedForm(persistentEntity) // populates mappingFactory.entityToPropertyMap as a side effect
        persistentEntity
    &#125;<p class="paragraph"/>    MappingConfigurationStrategy getMappingSyntaxStrategy() &#123;
        syntaxStrategy
    &#125;<p class="paragraph"/>    MappingFactory getMappingFactory() &#123;
        mappingFactory
    &#125;
&#125;</pre></div><p class="paragraph"/>
Notice how Neo4j provides a custom <code>GraphGormMappingFactory</code> and <code>GraphPersistentEntity</code> to allow the domain class configuration to be changed for a given Neo4j <code>Node</code>.<p class="paragraph"/><h3>The Datastore Interface</h3><p class="paragraph"/>The <code>org.grails.datastore.mapping.core.Datastore</code> interface is the equivalent of a SQL <code>DataSource</code> where by it provides the necessary capability to create a connection. In most cases one can simply subclass the <code>AbstractDatastore</code> super class and implement the <code>createSession</code> method. The following implementation is from the <code>SimpleMapDatastore</code> which implements GORM ontop of a <code>ConcurrentHashMap</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> Session createSession(Map&#60;<span class="java&#45;object">String</span>, <span class="java&#45;object">String</span>&#62; connectionDetails) &#123;
    <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> SimpleMapSession(<span class="java&#45;keyword">this</span>, getMappingContext(), getApplicationEventPublisher());
&#125;</pre></div><p class="paragraph"/>The implementation depends a lot on the underlying datastore. For example for JPA the following implementation is used:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> Session createSession(Map&#60;<span class="java&#45;object">String</span>, <span class="java&#45;object">String</span>&#62; connDetails) &#123;
    <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> JpaSession(<span class="java&#45;keyword">this</span>, <span class="java&#45;keyword">new</span> JpaTemplate(entityManagerFactory), transactionManager);
&#125;</pre></div><p class="paragraph"/>Notice that the <code>Datastore</code> also has a reference to the <code>MappingContext</code> discussed in the previous section.<p class="paragraph"/>
<h3>The Session Interface</h3><p class="paragraph"/>The <code>org.grails.datastore.mapping.core.Session</code> interface represents an active connection. It can be either stateful or stateless, depending on the implementation. For example of embedded databases where there is no network connection, a stateful session is not particularly useful, but a datastore that creates network connections you may want to cache returned instances to reduce load.<p class="paragraph"/>The <code>AbstractSession</code> class provides some support for creating stateful sessions, if you prefer a stateless implementation then simply implement <code>Session</code> or subclass <code>AbstractAttributeStoringSession</code>.<p class="paragraph"/>In general if you subclass <code>AbstractSession</code> the minimum you need to do is implement the <code>createPersister</code> method:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">protected</span> Persister createPersister(<span class="java&#45;object">Class</span> cls, MappingContext mappingContext) &#123;
    PersistentEntity entity = mappingContext.getPersistentEntity(cls.getName());
    <span class="java&#45;keyword">if</span> (entity == <span class="java&#45;keyword">null</span>) &#123;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>;
    &#125;
    <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> SimpleMapEntityPersister(mappingContext, entity, <span class="java&#45;keyword">this</span>,
        (SimpleMapDatastore) getDatastore(), publisher);
&#125;</pre></div><p class="paragraph"/>The example above is from the <code>SimpleMapSession</code> implementation, which creates a <code>SimpleMapEntityPersister</code> instance and returns it. Returning null indicates that the class cannot be persisted and an exception will be thrown


<h2 id="3.2 Implementing CRUD">3.2 Implementing CRUD</h2>
<h4>The EntityPersister Interface</h4><p class="paragraph"/>The <code>EntityPersister</code> interface is used to implement the basic Create, Read, Update and Delete (CRUD) operations. There are individual methods to implement such as <code>persistEntity</code>, <code>updateEntity</code>, <code>deleteEntity</code> and so on.<p class="paragraph"/>In many cases there is a representation of an entity in its "native" form as supplied by the datastore driver. For example in Cassandra this could be a <code>ColumnFamily</code>, or in MongoDB a <code>DBCollection</code>.<p class="paragraph"/>To support implementation such cases there is an abstract <code>NativeEntryEntityPersister&#60;T, K&#62;</code> super class that provides the basis for an implementation that maps a native entry, such as a MongoDB <code>DBObject</code> or a Neo4j <code>Node</code> to a persist entity and back again.<p class="paragraph"/>The 2 generic types of this superclass indicate the native entry type (example <code>DBObject</code> in MongoDB) and the native key type (example <code>ObjectId</code> in MongoDB). The MongoDB implementation looks like this:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class MongoEntityPersister <span class="java&#45;keyword">extends</span> NativeEntryEntityPersister&#60;DBObject, <span class="java&#45;object">Object</span>&#62;</pre></div><p class="paragraph"/>Note that <code>Object</code> is used for the key since MongoDB also supports Long and String-based identifiers.<p class="paragraph"/>They key methods that need implementing are defined below:
<ul class="star">
<li><code>getEntityFamily()</code> - Defines the the name of the entity group or family. This could be a database table, a Cassandra Column Family or a MongoDB collection.</li>
<li><code>T createNewEntry(String family)</code> - Creates a native entry ready to be inserted</li>
<li><code>Object getEntryValue(T nativeEntry, String property)</code> - Retrieves a value of entry and returns its Java object form. For example a "date" property stored as a String in the datastore would need to b returned as a java.util.Date at this point</li>
<li><code>setEntryValue(T nativeEntry, String key, Object value)</code> - Sets a value of the native entry, converting any Java objects to the required native format</li>
<li><code>deleteEntry(String family, K key, Object entry)</code> - Deletes an entry for the given family, native key and entry</li>
<li><code>T retrieveEntry(PersistentEntity persistentEntity, String family, Serializable key)</code> - Retrieves a native entry for the given entity, family and key</li>
<li><code>K storeEntry(PersistentEntity persistentEntity, EntityAccess entityAccess, K storeId, T nativeEntry)</code> - Stores a native entry for the given id</li>
<li><code>updateEntry(PersistentEntity persistentEntity, EntityAccess entityAccess, K key, T entry)</code> - Updates an entry</li>
<li><code>K generateIdentifier(PersistentEntity persistentEntity, T entry)</code> - Generate an identifier for the given native entry</li>
<li><code>PropertyValueIndexer getPropertyIndexer(PersistentProperty property)</code> - If the datastore requires manual indexing you'll need to implement a <code>PropertyIndexer</code> otherwise return null</li>
<li><code>AssociationIndexer getAssociationIndexer(T nativeEntry, Association association)</code> - If the datastore requires manual indexing you'll need to implement a <code>AssociationIndexer</code> otherwise return null</li>
</ul><p class="paragraph"/><h4>Create</h4><p class="paragraph"/>The <code>createNewEntry</code> method is used to create a native record that will be inserted into the datastore. In MongoDB this is a <code>DBObject</code> whilst in the implementation for <code>ConcurrentHashMap</code> it is another <code>Map</code>:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> DBObject createNewEntry(<span class="java&#45;object">String</span> family) &#123;
    <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> BasicDBObject();
&#125;</pre></div><p class="paragraph"/><h4>Read</h4><p class="paragraph"/>The <code>retrieveEntry</code> method is used to retrieve a native record for a given key:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">protected</span> DBObject retrieveEntry(<span class="java&#45;keyword">final</span> PersistentEntity persistentEntity,
        <span class="java&#45;object">String</span> family, <span class="java&#45;keyword">final</span> Serializable key) &#123;
    <span class="java&#45;keyword">return</span> mongoTemplate.execute(<span class="java&#45;keyword">new</span> DbCallback&#60;DBObject&#62;() &#123;
        <span class="java&#45;keyword">public</span> DBObject doInDB(DB con) <span class="java&#45;keyword">throws</span> MongoException, DataAccessException &#123;
            DBCollection dbCollection = con.getCollection(getCollectionName(persistentEntity));
            <span class="java&#45;keyword">return</span> dbCollection.findOne(key);
        &#125;
    &#125;);
&#125;</pre></div><p class="paragraph"/>Here you can see the <code>MongoDB</code> implementation that uses a Spring Data <code>MongoTemplate</code> to find a <code>DBObject</code> for the given key. There is a separate <code>storeEntry</code> method that is used to actually store the native object. In <code>MongoDB</code> this looks like:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> <span class="java&#45;object">Object</span> storeEntry(<span class="java&#45;keyword">final</span> PersistentEntity persistentEntity, <span class="java&#45;keyword">final</span> EntityAccess entityAccess,
                            <span class="java&#45;keyword">final</span> <span class="java&#45;object">Object</span> storeId, <span class="java&#45;keyword">final</span> DBObject nativeEntry) &#123;
    <span class="java&#45;keyword">return</span> mongoTemplate.execute(<span class="java&#45;keyword">new</span> DbCallback&#60;<span class="java&#45;object">Object</span>&#62;() &#123;
        <span class="java&#45;keyword">public</span> <span class="java&#45;object">Object</span> doInDB(DB con) <span class="java&#45;keyword">throws</span> MongoException, DataAccessException &#123;
            nativeEntry.put(MONGO_ID_FIELD, storeId);
            <span class="java&#45;keyword">return</span> storeId;
        &#125;
    &#125;);
&#125;</pre></div><p class="paragraph"/>Notice it doesn't actually do anything native insert into a MongoDB collection. This is because the Datastore API supports the notion of batch insert operations and flushing. In the case of <code>MongoDB</code> the <code>MongoSession</code> implementation overrides the <code>flushPendingInserts</code> method of <code>AbstractSession</code> and performs a batch insert of multiple MongoDB documents (ie <code>DBObject</code>s) at once:<p class="paragraph"/><div class="code"><pre>collection.insert(dbObjects.toArray(<span class="java&#45;keyword">new</span> DBObject&#91;dbObjects.size()&#93;), writeConcernToUse);</pre></div><p class="paragraph"/>Other datastores that  do not support batch inserts would instead to the insert in the <code>storeEntry</code> method itself. For example the implementation for <code>ConcurrentHashMap</code> looks like (note Groovy code):<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">protected</span> storeEntry(PersistentEntity persistentEntity, EntityAccess entityAccess, storeId, Map nativeEntry) &#123;
    <span class="java&#45;keyword">if</span> (!persistentEntity.root) &#123;
        nativeEntry.discriminator = persistentEntity.discriminator
    &#125;
    datastore&#91;family&#93;.put(storeId, nativeEntry)
    <span class="java&#45;keyword">return</span> storeId
&#125;</pre></div><p class="paragraph"/><h4>Update</h4><p class="paragraph"/>The <code>updateEntry</code> method is used to update an entry:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> void updateEntry(<span class="java&#45;keyword">final</span> PersistentEntity persistentEntity, <span class="java&#45;keyword">final</span> EntityAccess ea,
        <span class="java&#45;keyword">final</span> <span class="java&#45;object">Object</span> key, <span class="java&#45;keyword">final</span> DBObject entry) &#123;
    mongoTemplate.execute(<span class="java&#45;keyword">new</span> DbCallback&#60;<span class="java&#45;object">Object</span>&#62;() &#123;
        <span class="java&#45;keyword">public</span> <span class="java&#45;object">Object</span> doInDB(DB con) <span class="java&#45;keyword">throws</span> MongoException, DataAccessException &#123;
            <span class="java&#45;object">String</span> collectionName = getCollectionName(persistentEntity, entry);
            DBCollection dbCollection = con.getCollection(collectionName);
            <span class="java&#45;keyword">if</span> (isVersioned(ea)) &#123;
                // TODO <span class="java&#45;keyword">this</span> should be done with a CAS approach <span class="java&#45;keyword">if</span> possible
                DBObject previous = dbCollection.findOne(key);
                checkVersion(ea, previous, persistentEntity, key);
            &#125;<p class="paragraph"/>            MongoSession mongoSession = (MongoSession) session;
            dbCollection.update(dbo, entry, <span class="java&#45;keyword">false</span>, <span class="java&#45;keyword">false</span>, mongoSession.getWriteConcern());
            <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>;
        &#125;
    &#125;);
&#125;</pre></div><p class="paragraph"/>As you can see again the underlying database specific <code>update</code> method is used, in this case the <code>DBCollection</code>'s <code>update</code> method.<p class="paragraph"/><h4>Delete</h4><p class="paragraph"/>The <code>deleteEntry</code> method is used to delete an entry. For example in the <code>ConcurrentHashMap</code> implementation it is simply removed from the map:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">protected</span> void deleteEntry(<span class="java&#45;object">String</span> family, key, entry) &#123;
    datastore&#91;family&#93;.remove(key)
&#125;</pre></div><p class="paragraph"/>Whilst in <code>MongoDB</code> the <code>DBCollection</code> object's <code>remove</code> method is called:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> void deleteEntry(<span class="java&#45;object">String</span> family, <span class="java&#45;keyword">final</span> <span class="java&#45;object">Object</span> key, <span class="java&#45;keyword">final</span> <span class="java&#45;object">Object</span> entry) &#123;
    mongoTemplate.execute(<span class="java&#45;keyword">new</span> DbCallback&#60;<span class="java&#45;object">Object</span>&#62;() &#123;
        <span class="java&#45;keyword">public</span> <span class="java&#45;object">Object</span> doInDB(DB con) <span class="java&#45;keyword">throws</span> MongoException, DataAccessException &#123;
            DBCollection dbCollection = getCollection(con);<p class="paragraph"/>            MongoSession mongoSession = (MongoSession) session;
            dbCollection.remove(key, mongoSession.getWriteConcern());
            <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>;
        &#125;<p class="paragraph"/>        <span class="java&#45;keyword">protected</span> DBCollection getCollection(DB con) &#123;
            <span class="java&#45;keyword">return</span> con.getCollection(getCollectionName(getPersistentEntity()));
        &#125;
    &#125;);
&#125;</pre></div><p class="paragraph"/>Note that if the underlying datastore supports batch delete operations you may want override and implement the <code>deleteEntries</code> method which allows for deleting multiple entries in a single operation. The implementation for MongoDB looks like:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">protected</span> void deleteEntries(<span class="java&#45;object">String</span> family, <span class="java&#45;keyword">final</span> List&#60;<span class="java&#45;object">Object</span>&#62; keys) &#123;
    mongoTemplate.execute(<span class="java&#45;keyword">new</span> DbCallback&#60;<span class="java&#45;object">Object</span>&#62;() &#123;
        <span class="java&#45;keyword">public</span> <span class="java&#45;object">Object</span> doInDB(DB con) <span class="java&#45;keyword">throws</span> MongoException, DataAccessException &#123;
            <span class="java&#45;object">String</span> collectionName = getCollectionName(getPersistentEntity());
            DBCollection dbCollection = con.getCollection(collectionName);<p class="paragraph"/>            MongoSession mongoSession = (MongoSession) getSession();
            MongoQuery query = mongoSession.createQuery(getPersistentEntity().getJavaClass());
            query.in(getPersistentEntity().getIdentity().getName(), keys);<p class="paragraph"/>            dbCollection.remove(query.getMongoQuery());<p class="paragraph"/>            <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">null</span>;
        &#125;
    &#125;);
&#125;</pre></div><p class="paragraph"/>You'll notice this implementation uses a <code>MongoQuery</code> instance. Note that implementing an <code>EntityPersister</code> you have enabled basic CRUD operations, but not querying, which is a topic of the following sections. First, however secondary indices need to covered since they are required for querying.


<h2 id="3.3 Secondary Indices">3.3 Secondary Indices</h2>
Many datastores do not support secondary indices or require you to build your own. In cases like this you will need to implement a <code>PropertyIndexer</code>.<p class="paragraph"/><blockquote class="note">
If the underlying datastore supports secondary indexes then it is ok to just return a <code>null</code> PropertyIndexer and let the datastore handle the indexing
</blockquote><p class="paragraph"/>For example the <code>ConcurrentHashMap</code> implementation creates secondary indices by populating another <code>Map</code> containing the indices:<p class="paragraph"/><div class="code"><pre>void index(value, primaryKey) &#123;<p class="paragraph"/>    def index = getIndexName(value)
    def indexed = indices&#91;index&#93;
    <span class="java&#45;keyword">if</span> (indexed == <span class="java&#45;keyword">null</span>) &#123;
        indexed = &#91;&#93;
        indices&#91;index&#93; = indexed
    &#125;
    <span class="java&#45;keyword">if</span> (!indexed.contains(primaryKey)) &#123;
        indexed &#60;&#60; primaryKey
    &#125;
&#125;</pre></div><p class="paragraph"/>The implementation for Redis is very similar and stores the primary key in a Redis set:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> void index(<span class="java&#45;keyword">final</span> <span class="java&#45;object">Object</span> value, <span class="java&#45;keyword">final</span> <span class="java&#45;object">Long</span> primaryKey) &#123;
      <span class="java&#45;keyword">if</span> (value == <span class="java&#45;keyword">null</span>) &#123;
          <span class="java&#45;keyword">return</span>;
      &#125;
      <span class="java&#45;keyword">final</span> <span class="java&#45;object">String</span> primaryIndex = createRedisKey(value);
      redisTemplate.sadd(primaryIndex, primaryKey);
&#125;</pre></div><p class="paragraph"/>An index name is typically built from the entity name, property name and property value. The primary key of the entity is stored in this index for later querying. In fact there is a <code>query</code> method that needs to be implemented on <code>PropertyIndexer</code>. The <code>ConcurrentHashMap</code> implementation looks like this:<p class="paragraph"/><div class="code"><pre>List query(value, <span class="java&#45;object">int</span> offset, <span class="java&#45;object">int</span> max) &#123;
    def index = getIndexName(value)<p class="paragraph"/>    def indexed = indices&#91;index&#93;
    <span class="java&#45;keyword">if</span> (!indexed) &#123;
        <span class="java&#45;keyword">return</span> Collections.emptyList()
    &#125;
    <span class="java&#45;keyword">return</span> indexed&#91;offset..max&#93;
&#125;</pre></div><p class="paragraph"/>Depending on the characteristics of the underlying database you may want to do the indexing asynchronously or you may want to index into a search library such as Lucene. For datastores that are eventually consistent for example it makes sense to do all indexing asynchronously.<p class="paragraph"/>Finally, when an object is deleted it will need to removed from the indices. This can be done with the <code>deindex</code> method:<p class="paragraph"/><div class="code"><pre>void deindex(value, primaryKey) &#123;
    def index = getIndexName(value)
    def indexed = indices&#91;index&#93;
    <span class="java&#45;keyword">if</span> (indexed) &#123;
        indexed.remove(primaryKey)
    &#125;
&#125;</pre></div><p class="paragraph"/>


<h2 id="3.4 Implementing Querying">3.4 Implementing Querying</h2>
<h3>Introduction</h3><p class="paragraph"/>The <code>org.grails.datastore.mapping.query.Query</code> abstract class defines the query model and it is the job of the GORM implementor to translate this query model into an underlying database query. This is different depending on the implementation and may involve:
<ul class="star">
<li>Generating a String-based query such as SQL or JPA-QL</li>
<li>Creating a query object such as MongoDB's use of a <code>DBObject</code> to define queries</li>
<li>Generating for use with manually created Secondary indices as is the case with Redis</li>
</ul><p class="paragraph"/>The <code>Query</code> object defines the following:
<ul class="star">
<li>One or many <code>Criterion</code> that define the criteria to query by.</li>
<li>Zero or many <code>Projection</code> instances that define what the data you want back will look like.</li>
<li>Pagination parameters such as <code>max</code>, <code>offset</code></li>
<li>Sorting parameters</li>
</ul><p class="paragraph"/>There are many types of <code>Criterion</code> for each specific type of query, examples include <code>Equals</code>, <code>Between</code>, <code>Like</code> etc. Depending on the capabilities of the underlying datastore you may implement only a few of these.<p class="paragraph"/>There are also many types of <code>Projection</code> such as <code>SumProjection</code>, <code>MaxProjection</code> and <code>CountProjection</code>. Again you may implement only a few of these.<p class="paragraph"/><blockquote class="note">
If the underlying datastore doesn't for example support calculating a <code>sum</code> or <code>max</code> of a particular property, there is a <code>ManualProjections</code> class that you can use to perform these operations in memory on the client.
</blockquote><p class="paragraph"/>Writing a <code>Query</code> implementation is probably the most complex part of implementing a GORM provider, but starts by subclassing the <code>Query</code> class and implementing the <code>executeQuery</code> method:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class MongoQuery <span class="java&#45;keyword">extends</span> Query <span class="java&#45;keyword">implements</span> QueryArgumentsAware &#123;
     ...<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/><h3>Using the Query Model</h3><p class="paragraph"/>To implement querying you need to understand the Query model. As discussed a <code>Query</code> contains a list of <code>Criterion</code>, however the root <code>Criterion</code> could be a conjunction (an AND query) or a disjunction (an OR query). The <code>Query</code> may also contain a combination of regular criterion (=, !=, LIKE etc.) and junctions (AND, OR or NOT). Implementing a <code>Query</code> therefore requires writing a recursive method. The implementation for <code>ConcurrentHashMap</code> looks like<p class="paragraph"/><div class="code"><pre>Collection executeSubQueryInternal(criteria, criteriaList) &#123;
    SimpleMapResultList resultList = <span class="java&#45;keyword">new</span> SimpleMapResultList(<span class="java&#45;keyword">this</span>)
    <span class="java&#45;keyword">for</span> (Query.Criterion criterion in criteriaList) &#123;
        <span class="java&#45;keyword">if</span> (criterion <span class="java&#45;keyword">instanceof</span> Query.Junction) &#123;
            resultList.results &#60;&#60; executeSubQueryInternal(criterion, criterion.criteria)
        &#125;
        <span class="java&#45;keyword">else</span> &#123;
            PersistentProperty property = getValidProperty(criterion)
            def handler = handlers&#91;criterion.getClass()&#93;<p class="paragraph"/>            def results = handler?.call(criterion, property) ?: &#91;&#93;
            resultList.results &#60;&#60; results
        &#125;
    &#125;
&#125;</pre></div><p class="paragraph"/>Notice that if a <code>Junction</code> is encountered (which represents an AND, OR or NOT) then the method recurses to handle the junctions, otherwise a handler for the <code>Criterion</code> class is obtained and executed. The <code>handlers</code> map is a map of <code>Criterion</code> class to query handlers. The implementation for <code>Equals</code> looks like:<p class="paragraph"/><div class="code"><pre>def handlers = &#91;
    &#8230;
    (Query.Equals): &#123; Query.Equals equals, PersistentProperty property&#45;&#62;
        def indexer = entityPersister.getPropertyIndexer(property)
        <span class="java&#45;keyword">final</span> value = subqueryIfNecessary(equals)
        <span class="java&#45;keyword">return</span> indexer.query(value)
    &#125;
    &#8230;
&#93;</pre></div><p class="paragraph"/>Which simply uses the property indexer to query for all identifiers. Of course here we are a describing a case of a datastore (in this case <code>ConcurrentHashMap</code>) which doesn't support secondary indices. It may be that instead of manually querying the secondary indices in this way that you simply build a String-based or native query. For example in MongoDB this looks like:<p class="paragraph"/><div class="code"><pre>queryHandlers.put(Equals.class, <span class="java&#45;keyword">new</span> QueryHandler&#60;Equals&#62;() &#123;
    <span class="java&#45;keyword">public</span> void handle(PersistentEntity entity, Equals criterion, DBObject query) &#123;
        <span class="java&#45;object">String</span> propertyName = getPropertyName(entity, criterion);
        <span class="java&#45;object">Object</span> value = criterion.getValue();
        PersistentProperty property = entity.getPropertyByName(criterion.getProperty());
        MongoEntityPersister.setDBObjectValue(query, propertyName, value, entity.getMappingContext());
    &#125;
&#125;);</pre></div><p class="paragraph"/>Notice how the query in this case is a <code>DBObject</code>. For Gemfire again the implementation is different:<p class="paragraph"/><div class="code"><pre>queryHandlers.put(Equals.class, <span class="java&#45;keyword">new</span> QueryHandler() &#123;
    <span class="java&#45;keyword">public</span> <span class="java&#45;object">int</span> handle(PersistentEntity entity, Criterion criterion, StringBuilder q, List params, <span class="java&#45;object">int</span> index) &#123;
        Equals eq = (Equals) criterion;
        <span class="java&#45;keyword">final</span> <span class="java&#45;object">String</span> name = eq.getProperty();
        validateProperty(entity, name, Equals.class);<p class="paragraph"/>        q.append(calculateName(entity, name));
        <span class="java&#45;keyword">return</span> appendOrEmbedValue(q, params, index, eq.getValue(), EQUALS);
    &#125;
&#125;);</pre></div><p class="paragraph"/>In this case a <code>StringBuilder</code> is used to construct a OQL query from the <code>Query</code> model.


<h1 id="4. GORM Enhancer">4 GORM Enhancer</h1>
Once you have implemented the lower-level APIs you can trivially provide a GORM API to a set of Grails domain classes. For example consider the following simple domain class:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.persistence.&#42;<p class="paragraph"/>@Entity
class Book &#123;
    <span class="java&#45;object">String</span> title
&#125;</pre></div><p class="paragraph"/>
The following setup code can be written to enable GORM for MongoDB:<p class="paragraph"/><div class="code"><pre>// create context
def context = <span class="java&#45;keyword">new</span> MongoMappingContext(databaseName)
context.addPersistentEntity(Book)<p class="paragraph"/>// create datastore
def mongoDatastore = <span class="java&#45;keyword">new</span> MongoDatastore(context)
mongoDatastore.afterPropertiesSet()<p class="paragraph"/>// enhance
def enhancer = <span class="java&#45;keyword">new</span> MongoGormEnhancer(mongoDatastore, <span class="java&#45;keyword">new</span> DatastoreTransactionManager(datastore: mongoDatastore))
enhancer.enhance()<p class="paragraph"/>// use GORM!
def books = Book.list()</pre></div><p class="paragraph"/>They key part to enabling the usage of all the GORM methods (<code>list()</code>, dynamic finders etc.) is the usage of the <code>MongoGormEnhancer</code>. This class subclasses <code>org.grails.datastore.gorm.GormEnhancer</code> and provides some extensions to GORM specific to MongoDB. A subclass is not required however and if you don't require any datastore specific extensions you can just as easily use the regular <code>GormEnhancer</code>:<p class="paragraph"/><div class="code"><pre>def enhancer = <span class="java&#45;keyword">new</span> GormEnhancer(mongoDatastore, <span class="java&#45;keyword">new</span> DatastoreTransactionManager(datastore: mongoDatastore))
enhancer.enhance()</pre></div>


<h2 id="4.1 GORM APIs">4.1 GORM APIs</h2>
The <code>GormEnhancer</code> class defines three methods called <code>getStaticApi</code>, <code>getInstanceApi</code> and <code>getValidationApi</code> that return instances of <code>GormStaticApi</code>, <code>GormInstanceApi</code> and <code>GormValidationApi</code> respectively. If you wish to provide custom GORM functionality then you can subclass each of these and override one of the aforementioned methods to provide said functionality.<p class="paragraph"/>For example GORM for MongoDB does this to provide access to the underlying <code>DBCollection</code>:<p class="paragraph"/><div class="code"><pre>class MongoGormStaticApi&#60;D&#62; <span class="java&#45;keyword">extends</span> GormStaticApi&#60;D&#62; &#123;
    &#8230;
    /&#42;&#42;
     &#42; The actual collection that <span class="java&#45;keyword">this</span> entity maps to.
     &#42;
     &#42; @<span class="java&#45;keyword">return</span> The actual collection
     &#42;/
    DBCollection getCollection() &#123;
        MongoDatastore ms = datastore
        def template = ms.getMongoTemplate(persistentEntity)<p class="paragraph"/>        def coll = template.getCollection(ms.getCollectionName(persistentEntity))
        DBCollectionPatcher.patch(coll)
        <span class="java&#45;keyword">return</span> coll
    &#125;    
&#125;</pre></div><p class="paragraph"/>With this method in place users of GORM for MongoDB can access the underlying MongoDB API directly:<p class="paragraph"/><div class="code"><pre>def dbo = Book.collection.findOne()</pre></div><p class="paragraph"/>The enable usage of this API the <code>MongoGormEnhancer</code> extends and overrides the <code>getStaticApi</code> method:<p class="paragraph"/><div class="code"><pre>class MongoGormEnhancer <span class="java&#45;keyword">extends</span> GormEnhancer &#123;
    &#8230;
    <span class="java&#45;keyword">protected</span> &#60;D&#62; GormStaticApi&#60;D&#62; getStaticApi(<span class="java&#45;object">Class</span>&#60;D&#62; cls) &#123;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> MongoGormStaticApi&#60;D&#62;(cls, datastore, finders)
    &#125;   
&#125;</pre></div>


<h1 id="5. Using the Test Compatibility Kit">5 Using the Test Compatibility Kit</h1>
The <code>grails-datastore-gorm-tck</code> project provides a few hundred tests that ensure a particular GORM implementation is compliant. To use the TCK you need to define a dependency on the TCK in the subprojects <code>build.gradle</code> file:<p class="paragraph"/><div class="code"><pre>testCompile project(':grails&#45;datastore&#45;gorm&#45;tck')</pre></div><p class="paragraph"/>Then create a <code>Setup.groovy</code> file that sets up your custom datastore in your implementation.<p class="paragraph"/>For example the <code>ConcurrentHashMap</code> implementation has one defined in <code>grails-datastore-gorm-test/src/test/groovy/org/grails/datastore/gorm/Setup.groovy</code>:<p class="paragraph"/><div class="code"><pre>class Setup &#123;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> destroy() &#123;
        // noop
    &#125;
    <span class="java&#45;keyword">static</span> Session setup(classes) &#123;<p class="paragraph"/>        def ctx = <span class="java&#45;keyword">new</span> GenericApplicationContext()
        ctx.refresh()
        def simple = <span class="java&#45;keyword">new</span> SimpleMapDatastore(ctx)<p class="paragraph"/>        &#8230;
        <span class="java&#45;keyword">for</span> (cls in classes) &#123;
            simple.mappingContext.addPersistentEntity(cls)
        &#125;<p class="paragraph"/>        &#8230;
        def enhancer = <span class="java&#45;keyword">new</span> GormEnhancer(simple, <span class="java&#45;keyword">new</span> DatastoreTransactionManager(datastore: simple))
        enhancer.enhance()<p class="paragraph"/>        simple.mappingContext.addMappingContextListener(&#123; e &#45;&#62; enhancer.enhance e &#125; as MappingContext.Listener)<p class="paragraph"/>        simple.applicationContext.addApplicationListener <span class="java&#45;keyword">new</span> DomainEventListener(simple)
        simple.applicationContext.addApplicationListener <span class="java&#45;keyword">new</span> AutoTimestampEventListener(simple)<p class="paragraph"/>        <span class="java&#45;keyword">return</span> simple.connect()
    &#125;
&#125;</pre></div><p class="paragraph"/>Some setup code has been omitted for clarity but basically the <code>Setup.groovy</code> class should initiase the <code>Datastore</code> and return a <code>Session</code> from the static <code>setup</code> method which gets passed a list of classes that need to be configured.<p class="paragraph"/>With this done all of the TCK tests will run against the subproject. If a particular test cannot be implemented because the underlying datastore doesn't support the feature then you can create a test that matches the name of the test that is failing and it will override said test.<p class="paragraph"/>For example SimpleDB doesn't support pagination so there is a <code>grails.gorm.tests.PagedResultSpec</code> class that overrides the one from the TCK. Each test is a Spock specification and Spock has an <code>Ignore</code> annotation that can be used to ignore a particular test:<p class="paragraph"/><div class="code"><pre>/&#42;&#42;
 &#42; Ignored <span class="java&#45;keyword">for</span> SimpleDB because SimpleDB doesn't support pagination
 &#42;/
@Ignore
class PagedResultSpec <span class="java&#45;keyword">extends</span> GormDatastoreSpec&#123;
   &#8230;
&#125;</pre></div>


<h1 id="6. Creating a GORM implementatio Step by Step">6 Creating a GORM implementatio Step by Step</h1>
To get started with your a new GORM implementation the following steps are required:<p class="paragraph"/><h3>Initial Directory Creation</h3><p class="paragraph"/><div class="code"><pre>$ git clone git@github.com:SpringSource/grails&#45;data&#45;mapping.git 
$ cd grails&#45;data&#45;mapping
$ mkdir grails&#45;datastore&#45;gorm&#45;xyz</pre></div><p class="paragraph"/><h3>Setup Gradle Build</h3><p class="paragraph"/>Create build.gradle:<p class="paragraph"/><div class="code"><pre>$ vi grails&#45;datastore&#45;gorm&#45;xyz/build.gradle</pre></div><p class="paragraph"/>With contents:<p class="paragraph"/><div class="code"><pre>dependencies &#123;
    compile project(':grails&#45;datastore&#45;gorm'),
            project(':grails&#45;datastore&#45;web'),
            project(':grails&#45;datastore&#45;gorm&#45;plugin&#45;support')<p class="paragraph"/>    testCompile project(':grails&#45;datastore&#45;gorm&#45;test'),
                project(':grails&#45;datastore&#45;gorm&#45;tck')
    testRuntime 'javax.servlet:servlet&#45;api:2.5'
    testRuntime 'org.grails:grails&#45;gorm:$grailsVersion'
    testRuntime 'org.grails:grails&#45;web:$grailsVersion'<p class="paragraph"/>&#125;</pre></div><p class="paragraph"/>Add new project to settings.gradle in root project:<p class="paragraph"/><div class="code"><pre>$ vi settings.gradle</pre></div><p class="paragraph"/>Changes shown below:<p class="paragraph"/><div class="code"><pre>// GORM Implementations
'grails&#45;datastore&#45;gorm&#45;jpa',
'grails&#45;datastore&#45;gorm&#45;neo4j',
'grails&#45;datastore&#45;gorm&#45;xyz',
....</pre></div><p class="paragraph"/><h3>Create Project Source Directories</h3><p class="paragraph"/><div class="code"><pre>$ mkdir grails&#45;datastore&#45;gorm&#45;xyz/src/main/groovy
$ mkdir grails&#45;datastore&#45;gorm&#45;xyz/src/test/groovy</pre></div><p class="paragraph"/><h3>Generate IDE Project Files and Import into IDE</h3><p class="paragraph"/><div class="code"><pre>$ gradlew grails&#45;datastore&#45;gorm&#45;xyz:idea</pre></div><p class="paragraph"/>Or<p class="paragraph"/><div class="code"><pre>$ gradlew grails&#45;datastore&#45;gorm&#45;xyz:eclipse</pre></div><p class="paragraph"/><h3>Implement Required Interfaces</h3><p class="paragraph"/>In <code>src/main/groovy</code> create implementations:
<ul class="star">
<li><code>org.grails.datastore.xyz.XyzDatastore</code> extends and implements <code>org.grails.datastore.mapping.core.AbstractDatastore</code></li>
<li><code>org.grails.datastore.xyz.XyzSession</code> extends and implements <code>org.grails.datastore.mapping.core.AbstractSession</code></li>
<li><code>org.grails.datastore.xyz.engine.XyzEntityPersister</code> extends and implements <code>org.grails.datastore.mapping.engine.NativeEntryEntityPersister</code></li>
<li><code>org.grails.datastore.xyz.query.XyzQuery</code> extends and implements <code>org.grails.datastore.mapping.query.Query</code></li>
</ul><p class="paragraph"/><h3>Create Test Suite </h3><p class="paragraph"/>In <code>src/test/groovy</code> create <code>org.grails.datastore.gorm.Setup</code> class to configure TCK:<p class="paragraph"/><div class="code"><pre>class Setup &#123;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> xyz
    <span class="java&#45;keyword">static</span> destroy() &#123;
        xyz.disconnect()
    &#125;
    <span class="java&#45;keyword">static</span> Session setup(classes) &#123;
        def ctx = <span class="java&#45;keyword">new</span> GenericApplicationContext()
        ctx.refresh()
        xyz = <span class="java&#45;keyword">new</span> XyzDatastore(ctx)
        <span class="java&#45;keyword">for</span> (cls in classes) &#123;
            xyz.mappingContext.addPersistentEntity(cls)
        &#125;<p class="paragraph"/>
        def enhancer = <span class="java&#45;keyword">new</span> GormEnhancer(xyz, <span class="java&#45;keyword">new</span> DatastoreTransactionManager(datastore: xyz))
        enhancer.enhance()<p class="paragraph"/>        xyz.mappingContext.addMappingContextListener(&#123; e &#45;&#62; enhancer.enhance e &#125; as MappingContext.Listener)
        xyz.applicationContext.addApplicationListener <span class="java&#45;keyword">new</span> DomainEventListener(xyz)
        xyz.applicationContext.addApplicationListener <span class="java&#45;keyword">new</span> AutoTimestampEventListener(xyz)<p class="paragraph"/>        xyz.connect()
    &#125;
&#125;</pre></div><p class="paragraph"/>Then in <code>src/test/groovy</code> create test suite class to allow running tests in IDE (without this you won't be able to run TCK tests from the IDE). Example test suite:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">package</span> org.grails.datastore.gorm<p class="paragraph"/><span class="java&#45;keyword">import</span> org.junit.runners.Suite.SuiteClasses
<span class="java&#45;keyword">import</span> org.junit.runners.Suite
<span class="java&#45;keyword">import</span> org.junit.runner.RunWith
<span class="java&#45;keyword">import</span> grails.gorm.tests.&#42;<p class="paragraph"/>/&#42;&#42;
 &#42; @author graemerocher
 &#42;/
@RunWith(Suite)
@SuiteClasses(&#91;
  FindByMethodSpec,
  ListOrderBySpec
&#93;)
class XyzTestSuite &#123;
&#125;</pre></div><p class="paragraph"/><h3>Implement the TCK!</h3><p class="paragraph"/>Keep iterating until you have implemented all the tests in the TCK.<p class="paragraph"/>

                    </div>
                </td>
                <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                    <div class="menu-block"><h1 class="menu-title" onclick="toggleRef(this.parentNode.childNodes[1])">Implementations</h1><div class="menu-sub">
                        
                        
                        <div class="menu-item"><a href="../ref/Implementations/ConcurrentHashMap.html">ConcurrentHashMap</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Implementations/Hibernate.html">Hibernate</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Implementations/JPA.html">JPA</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Implementations/MongoDB.html">MongoDB</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Implementations/Neo4j.html">Neo4j</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Implementations/Redis.html">Redis</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Implementations/Riak.html">Riak</a>
                        </div>
                        
                        <div class="menu-item"><a href="../ref/Implementations/SimpleDB.html">SimpleDB</a>
                        </div>
                        
                        </div>
                    </div>
                    
                </div>
            </div>
        </td>
            </tr>
        </table>

        <div id="footer">
            
            
        </div>



<script type="text/javascript" src="../js/docs.js"></script>

    </body>
</html>
